Notes on the development process
--------------------------------

This software was developed in 2002-2003 using an approach, in which small prototypes were gradually expanded and their functionality increased. Requirements were constantly changing, since new algorithms had different requirements for e.g. source note data formats. The use of Ruby, a new niche language at the time, resulted in the necessary refactoring and design changes being easier to implement (though graphical user interfaces were difficult to implement due to bugs and incomplecities in wrapper libraries).

The original plan was to assign a group of four students (including me) to write a server in C, into which algorithms written by researchers could later be plugged in. However, the group did not have a clear idea of what the future and existing algorithms require from the server. Also, server programming in C was very low-level, slow and complicated. The project however produced the required server. 

Later when it was my job to implement some algorithms into that framework and the algorithm in question was designed to use the concept of a chord, the server interfaces did not support it, as it was not part of the original requirements. Since I had not written those parts, it was frustrating to try to introduce the necessary changes. The code base was also large and inflexible. 

At this point I had used Ruby and GTK to implement graphical user interfaces for our C administration programs. After a lot of frustration with trying to fit the algorithms in the server I decided to trash everything and rewrite the whole thing in Ruby, implementing only the parts essential to performance in C. I also decided to discard the idea of putting all songs in one long string and indexing the song boundaries to an array. Instead, I used self-containing song objects belonging to a collection of songs.

The next phase was a DRb server with graphical user interface implemented with Gtk. Note data was stored in Ruby arrays. Algorithms could first be prototyped in Ruby, then implemented in C, which was very practical and fluent, since the principle and correct functioning of the algorithm could be checked before entering the C debugging cycle.

Next there was an attempt to store note data in Ruby objects (Chord and Note). This failed, because space requirements multiplied by about 10. I suppose this could have been predicted, has it not been my lack of knowledge of object-oriented languages.

One of the requirements was to have graphical desktop user interface with a piano keyboard for entering the melody to be searched. GTK did not support canvas objects, the documentation was outdated or missing large parts. Tk had better documentation but was clumsy and not object-oriented. In any case, it was hard to imagine an average user succeeding in installing Ruby, Gtk, Ruby-Gtk etc. on their Windows desktops. 

Therefore the idea of implementing a desktop client was discarded. Instead, it was implemented as a Java applet (the hype technology of the time) and the software was recast as a WWW application with minimal effort. The only issue was to implement HTML generation for results in C, since string concatenation in Ruby seemed to be a major bottleneck. 

After the failed attempt to use objects to store note data, to overcome the space requirement problems, note data was now stored as variable-length chords in C strings. This made it infeasible to create prototypes in Ruby and slowed down the development process quite a lot. Although the strings are accessible from Ruby, accessing them is too complicated to be useful in prototyping. 

On afterthought, the usefulness of the variable-length chord data structure is unclear. It simplified the implementation of bit-parallel string processing algorithms like Monopoly and saved some space, but later when it was necessary to implement algorithms with a different, geometric, approach, it was a burden. It made implementation of geometric algorithms unnecessary complex, and the algorithms themselves are very complex to implement, so the additional complexity was a major issue. 

Currently there is a variable-length chord note data format, accompanied with a format where there is a string for each track, and each track contains only the highest note in the chord (due to MIDI limitations). This format was necessary, because algorithm designers wanted to use this simpler format. So the vision of one source format did not realize. Different formats seemed the only way to adapt to contradictory requirements. At the time, there was no design that would have solved all the problems.

On the practical side, our main www server does not allow execution of scripts, so I had to put them in my home directory. However I wanted the URL to be to the main server, so I split the package to client part which contains applet and HTML, and a server part containing everything else. This was trivial with DRb, and in stark contrast to the original attempt of client-server programming in C. Due to high load on the public servers I put the server part on my personal desktop computer for a while, but then I could not e.g. boot to different operating systems and had to keep it on all the time. After an upgrade of the public server I moved the server part back there. 

The weak points in the project were version control and testing. Partly because of these complexities with requirements and their changes, partly because I was developing this alone, and partly because version control was not common or was based on centralized systems at the time and the department didn't host such a system, version control was based on tarballs. 

Also, unit testing was not as common at the time. Small datasets included in the distribution were used in more thorough testing. Testing with large datasets is possible e.g. by comparing that algorithms that should produce identical results actually do so. This kind of testing was done during coding, but was not formally documented. 

However, performance testing was naturally a central feature of the project. It was done with a sampling tester program and documented in the publications. 

A practical issue was that in the beginning we did not have any MIDI files free of copyright-related problems. I spent time looking for some and finally found the Mutopia collection. Another problem was lack of sufficient documentation on how to code C extensions to Ruby. In practice it was largely based on trial and error.

In retrospect, the project should have been started by implementing a couple of algorithms with different requirements first, then building a server around it (essentially, this is what happened in the rewrite). One could also think that the system should have been designed more thoroughly before coding phase. In practice it seemed that the incomplete knowledge of what the requirements really were, their constant changing, and incomplete knowledge of the tools could have resulted to six different models and no functional software in the same time that was spent prototyping. 

The process may be considered 'agile'. In the spirit of agile, when the project ended, I already had plans on how to rewrite it. The structure had gotten a bit complex and the whole system was a bit hard to handle. The division to client and server was no longer necessary. An option to solve the issue of multiple source formats would have been a conversion layer between the algorithms and the actual data. The interface would have allowed for accessing the same data as track strings, chords or plain vector data. This would however probably have decreased performance, and the interface would have become quite complex, since algorithms may need to access the data in any order or way. Another option would have been to rewrite all algorithms to use the same format. This would have not been feasible as it would have changed the structure of the algorithms. 
